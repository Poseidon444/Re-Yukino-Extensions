import '../utils.ht';

class GogoPlay {
    static const baseURL = 'https://gogoplay4.com';
    
    static final defaultHeaders = {
        'User-Agent': Http.defaultUserAgent,
    };

    static final cKey = Converter.utf8Encode('63976882873559819639988080820907');
    static final cIv = Converter.utf8Encode('4770478969418267');
    static final cMode = 'cbc';
    static final cPadding = 'none';
    static final cCustomPadding = BytesContainer.fromList([8, 8, 8, 8, 8, 8, 8, 8]);

    static fun ajaxApiURL(baseURL, id) {
        return Http.ensureURL('${baseURL}/encrypt-ajax.php?id=${id}');
    }

    static fun tryGetQuality(url) {
        for (final x in ['360p', '480p', '720p', '1080p']) {
            if (url.contains(x)) return x;
        }

        return 'unknown';
    }

    static fun parse(_url) {
        final url = Http.ensureURL(_url);

        return AsyncTask.resolve(
            () => Http.fetch(
                method: 'get',
                url: Http.ensureURL(url),
                headers: defaultHeaders
            ),
            onDone: fun (resp) {
                if (url.contains('streaming')) {
                    return parseStreaming(url, resp);
                } else if (url.contains('embedplus')) {
                    return parseEmbed(url, resp);
                } else {
                    return [];
                }
            }
        );
    }

    // Source: (The credit goes to them)
    //  - https://github.com/justfoolingaround/animdl/blob/master/animdl/core/codebase/extractors/gogoplay/__init__.py
    //  - https://github.com/saikou-app/saikou/blob/master/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
    static fun parseStreaming(url, resp) {
        final baseURL = getBaseURL(url);
        final document = HtmlElement.parse(resp.body);

        final id = Regex('id=([^&]+)').firstMatch(url)?.group(1);
        final encrypted = document.querySelector('script[data-name="episode"]')?.attributes['data-value'];
        if (id == null || encrypted == null) return [];

        final secretKey = cDecrypt(Converter.base64Decode(encrypted));
        final encryptedId = cEncrypt(Converter.utf8Encode(Converter.utf8Decode(secretKey).split('&').first));

        return AsyncTask.resolve(
            () => Http.fetch(
                method: 'get',
                url: ajaxApiURL(baseURL, Converter.base64Encode(encryptedId)),
                headers: Collection.mergeMap(defaultHeaders, {
                    'X-Requested-With': 'XMLHttpRequest',
                }),
            ),
            onDone: fun (resp) {
                final rawParsed = Converter.jsonDecode(resp.body);
                final dData = Converter.utf8Decode(
                    cDecrypt(
                        Converter.base64Decode(rawParsed['data'])
                    )
                ).replaceFirst('o"<P{#meme":', 'e":[{"file":');
                final parsed = Converter.jsonDecode(
                    Regex('([\\S\\s]+})[^}]+$').firstMatch(dData).group(1)
                );

                return Collection.mapList(
                    Collection.mergeList(parsed['source'], parsed['source_bk']),
                    fun (i, x) {
                        final srcURL = Http.ensureURL(x['file']);

                        return EpisodeSource(
                            url: srcURL,
                            headers: defaultHeaders,
                            quality: tryGetQuality(srcURL),
                            locale: $.defaultLocale,
                        );
                    },
                );
            },
        );
    }

    static fun parseEmbed(url, resp) {
        return Collection.mapList(
            Regex('file:\\s+[\'"]([^\'"]+)[\'"]').allMatches(resp.body) ?? [],
            fun (i, x) {
                final srcURL = Http.ensureURL(x.group(1));
                
                return EpisodeSource(
                    url: srcURL,
                    headers: defaultHeaders,
                    quality: tryGetQuality(srcURL),
                    locale: $.defaultLocale,
                );
            },
        );
    }

    static fun getBaseURL(url) {
        return Regex('https?:\\/\\/[^/]+').firstMatch(url).group(0);
    }

    static fun cDecrypt(data) {
        return Crypto.aesDecrypt(
            encrypted: data,
            key: cKey,
            iv: cIv,
            mode: cMode,
            padding: cPadding,
        );
    }

    static fun cEncrypt(data) {
        return Crypto.aesEncrypt(
            input: data.add(cCustomPadding),
            key: cKey,
            iv: cIv,
            mode: cMode,
            padding: cPadding,
        );
    }
}
