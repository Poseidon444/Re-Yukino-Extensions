import '../utils.ht';

class GogoPlay {
    static final defaultHeaders = {
        'User-Agent': Http.defaultUserAgent,
    };

    static final cMode = 'cbc';
    static final cPadding = 'pkcs7';
    static final cCustomPadding = BytesContainer.fromList(Collection.filledList(8, 8));

    static fun ajaxApiURL(baseURL, query) {
        return URL.ensureURL('${baseURL}/encrypt-ajax.php?${query}');
    }

    static fun tryGetQuality(url) {
        for (final x in ['360p', '480p', '720p', '1080p']) {
            if (url.contains(x)) return x;
        }

        return 'unknown';
    }

    // Source: (The credit goes to them)
    //  - https://github.com/justfoolingaround/animdl/blob/master/animdl/core/codebase/extractors/gogoplay/__init__.py
    //  - https://github.com/saikou-app/saikou/blob/master/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
    static fun parse(_url) {
        final url = URL.ensureURL(_url);
        final parsedUrl = URL.parse(url);

        final id = parsedUrl.queryParameters['id'];
        if (id == null) return [];

        return AsyncTask.resolve(
            () => Http.fetch(
                method: 'get',
                url: url,
                headers: Collection.mergeMap(defaultHeaders, {
                    'Referer': parsedUrl.origin,
                }),
            ),
            onDone: fun (resp) {
                final [_fKeyMatch, _ivMatch] = Regex('container-(\d+)').allMatches(resp.body);

                final _fKey = _fKeyMatch?.group(1);
                final _sKey = Regex('videocontent-(\d+)').firstMatch(resp.body)?.group(1);
                final _iv = _ivMatch?.group(1);
                if (!_fKey || !_sKey || !_iv) return [];

                final fKey = Converter.utf8Encode(_fKey);
                final sKey = Converter.utf8Encode(_sKey);
                final iv = Converter.utf8Encode(_iv);

                final encryptedId = cEncrypt(
                    data: Converter.utf8Encode(id),
                    key: fKey,
                    iv: iv,
                );

                // Needs fixing
                final queryParameters = Collection.mergeMap({}, parsedUrl.queryParameters);
                queryParameters['id'] = Converter.base64Encode(encryptedId);
                queryParameters['alias'] = id;
                queryParameters['op'] = '2';
                queryParameters['refer'] = $.baseURL;

                return AsyncTask.resolve(
                    () => Http.fetch(
                        method: 'get',
                        url: ajaxApiURL(
                            parsedUrl.origin,
                            URL.joinQueryParameters(queryParameters),
                        ),
                        headers: Collection.mergeMap(defaultHeaders, {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Referer': url,
                        }),
                    ),
                    onDone: fun (resp) {
                        final rawParsed = Converter.jsonDecode(resp.body);
                        final dData = Converter.utf8Decode(
                            cDecrypt(
                                data: Converter.base64Decode(rawParsed['data']),
                                key: sKey,
                                iv: iv,
                            )
                        ).replaceFirst('o"<P{#meme":', 'e":[{"file":');
                        
                        final parsed = Converter.jsonDecode(dData);
                        return Collection.mapList(
                            Collection.mergeList(parsed['source'], parsed['source_bk']),
                            fun (i, x) {
                                final srcURL = URL.ensureURL(x['file']);

                                return EpisodeSource(
                                    url: srcURL,
                                    headers: defaultHeaders,
                                    quality: tryGetQuality(srcURL),
                                    locale: $.defaultLocale,
                                );
                            },
                        );
                    },
                );
            },
        );
    }

    static fun cDecrypt({ data, key, iv }) {
        return Crypto.aesDecrypt(
            encrypted: data,
            key: key,
            iv: iv,
            mode: cMode,
            padding: cPadding,
        );
    }

    static fun cEncrypt({ data, key, iv }) {
        return Crypto.aesEncrypt(
            input: data,
            key: key,
            iv: iv,
            mode: cMode,
            padding: cPadding,
        );
    }
}
