const BASE_URL = 'https://tenshi.moe';

final defaultHeaders = {
    'User-Agent': Http.defaultUserAgent,
    'Referer': BASE_URL,
}

var webview;

fun getWebview(trace) {
    if (webview != null && !webview.disposed) {
        trace.add('Returning previous DOM');
        return webview;
    }

    trace.add('Creating new DOM');

    return Promise.resolve(
        () => Webview.create(),
        trace: trace,
        onDone: fun (res) {
            webview = res;
            return webview;
        },
    );
}

fun getSite(url, trace) {
    trace.add('Preparing DOM');

    return Promise.resolve(
        () => getWebview(trace),
        trace: trace,
        onDone: fun (_) {
            trace.add('Opening URL: "${url}"');

            return Promise.resolve(
                () => webview.open(url, 'domContentLoaded'),
                onDone: fun (_) {
                    trace.add('Trying to bypass browser check');

                    return Promise.resolve(
                        () => webview.tryBypassBrowserVerification(fun (html) {
                            return html.contains('href="https://ddos-guard.net"');
                        }),
                        trace: trace,
                        onDone: fun (bypassed) {
                            if (!bypassed) return Flaw.throwFlaw('Failed to bypass browser check', null, trace);
                            return webview;
                        },
                    );
                }
            );
        }
    );
}

fun searchURL(terms) {
    return Http.ensureURL('${BASE_URL}/anime?q=${terms}');
}

fun defaultLocale() {
    return "en";
}

fun search(terms, locale) {
    final trace = TaskTrace();
    final url = searchURL(terms);

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    final document = HtmlElement.parse(html);

                    return Collection.mapList(
                        document.querySelectorAll('.anime-loop li'),
                        fun (i, x) {
                            final link = x.querySelector('a');
                            final title = link.querySelector('.label .text-primary').text.trim();
                            final url = link.attributes['href'].trim();

                            return SearchInfo(
                                title: title,
                                url: Http.ensureURL(url),
                                locale: locale,
                            );
                        }
                    );
                }
            );
        }
    );
}

fun getInfo(url, locale) {
    final trace = TaskTrace();
    final url = Http.ensureURL(url);

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    final document = HtmlElement.parse(html);

                    final estimated = document.querySelector('.entry-episodes .badge.badge-secondary.align-top').text.trim();
                    final trimmedURL = url.endsWith('/') ? url.substring(0, url.length - 1) : url;

                    final episodes = Collection.mapList(
                        Collection.rangeList(0, int.parse(estimated)),
                        fun (i: num, x: num) {
                            final epNum = '${x + 1}';
                            
                            return EpisodeInfo(
                                episode: epNum,
                                url: Http.ensureURL('${trimmedURL}/${epNum}'),
                                locale: locale
                            );
                        }
                    );

                    return AnimeInfo(
                        title: document.querySelector('.entry-header').text.trim(),
                        url: Http.ensureURL(url),
                        thumbnail: ImageDescriber(
                            url: Http.ensureURL(document.querySelector('img.cover-image').attributes['src'].trim()),
                            headers: defaultHeaders,
                        ),
                        episodes: episodes,
                        locale: locale,
                        availableLocales: [
                            locale
                        ]
                    );
                }
            );
        }
    );
}

fun getSources(episode) {
    final trace = TaskTrace();
    final url = episode.url;

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    final iframeURL = Regex('<iframe src="([^"]+)"').firstMatch(html).group(1);

                    webview.addExtraHeaders({
                        'Referer': url,
                    });

                    return Promise.resolve(
                        () => getSite(iframeURL, trace),
                        trace: trace,
                        onDone: fun (_) {
                            webview.addExtraHeaders({
                                'Referer': null,
                            });

                            return Promise.resolve(
                                () => webview.getHtml(),
                                trace: trace,
                                onDone: fun (html2) {
                                    final sources = Regex('sources:[\\s]+\\[([^\\]]+)').firstMatch(html2).group(1);

                                    return Collection.mapList(
                                        Regex('src:[\\s]+?["\']([^\'"]+)[\\S\\s]+?size:[\\s]+?(\\d+)').allMatches(sources),
                                        fun (i, x) {
                                            return EpisodeSource(
                                                url: Http.ensureURL(x.group(1)),
                                                quality: x.group(2),
                                                headers: Collection.mergeMap(defaultHeaders, {
                                                    'Referer': url,
                                                }),
                                                locale: episode.locale,
                                            );
                                        }
                                    );  
                                }
                            );
                        }
                    );
                }
            );
        }
    );
}
