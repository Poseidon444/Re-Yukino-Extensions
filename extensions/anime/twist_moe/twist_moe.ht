const BASE_URL = 'https://twist.moe';
const BASE_API_URL = 'https://api.twist.moe/api';

const SECRET_KEY = '267041df55ca2b36f2e322d05ee2c9cf';
const ACCESS_TOKEN = '0df14814b9e590a1f26d3071a4ed7974';

final defaultHeaders = {
    'User-Agent': Http.defaultUserAgent,
    'Referer': BASE_URL,
    'x-access-token': ACCESS_TOKEN,
}

fun searchApiURL() {
    return '${BASE_API_URL}/anime';
}

fun animeURL(slug) {
    return Http.ensureURL('${BASE_URL}/a/${slug}');
}

fun animeApiURL(slug) {
    return Http.ensureURL('${BASE_API_URL}/anime/${slug}');
}

fun animeSourcesURL(slug) {
    return'${animeApiURL(slug)}/sources';
}

fun extractSlugFromURL(url) {
    return Regex('https?:\\/\\/twist\\.moe\\/a\\/([^\\/]+)').firstMatch(url).group(1);
}

fun defaultLocale() {
    return "en";
}

var searcher;

fun search(terms, locale) {
    if (searcher != null) {
        return searcher(terms);
    }

    return Promise.resolve(
        () => Http.fetch(
            method: 'get',
            url: searchApiURL(),
            headers: defaultHeaders
        ),
        onDone: fun (resp) {
            final parsed = Converter.jsonDecode(resp.body);

            final items = Collection.mapList(parsed, fun (i, x) {
                return {
                    'title': x['title'],
                    'altTitle': x['altTitle'] ?? '',
                    'url': Http.ensureURL(animeURL(x['slug']['slug'])),
                    'locale': locale,
                };
            });

            searcher = fun (terms) {
                final fuzzy = FuzzySearch(
                    items: items,
                    keys: [
                        FuzzySearchKey(
                            getter: (x) => x['title'],
                            weight: 2.0,
                        ),
                        FuzzySearchKey(
                            getter: (x) => x['altTitle'],
                        ),
                    ]
                );

                return Collection.mapList(
                    fuzzy.search(terms, 10),
                    (i, x) => SearchInfo(
                        title: x.item['title'],
                        url: x.item['url'],
                        locale: x.item['locale'],
                    ),
                );
            };

            return searcher(terms);
        },
    );
}

fun getInfo(url, locale) {
    final slug = extractSlugFromURL(url);

    return Promise.resolve(
        () => Http.fetch(
            method: 'get',
            url: animeApiURL(slug),
            headers: defaultHeaders,
        ),
        onDone: fun (resp) {
            final parsed = Converter.jsonDecode(resp.body);
            final animeURLP = animeURL(slug);

            return AnimeInfo(
                title: parsed['title'],
                url: animeURLP,
                episodes: Collection.mapList(parsed['episodes'], fun (i, x) {
                    final epNum = x['number'].toString();

                    return EpisodeInfo(
                        episode: epNum,
                        url: Http.ensureURL('${animeURLP}/${epNum}'),
                        locale: locale,
                    );
                }),
                locale: locale,
                availableLocales: [
                    locale
                ]
            );
        },
    );
}

final sourceCache = {};

fun generateSourceKey(salt) {
    const limit = 48;

    final data = Converter.utf8Encode(SECRET_KEY).add(salt);
    var key = Crypto.md5Convert(data);
    var outputKey = key.clone();

    while (outputKey.length < limit) {
        key = Crypto.md5Convert(key.add(data));
        outputKey = outputKey.add(key);
    }

    return outputKey.sublist(0, limit);
}

fun decryptSourceURL(url) {
    final encrypted = Converter.base64Decode(url);
    final key = generateSourceKey(encrypted.sublist(8, 16));

    return Converter.utf8Decode(
        Crypto.aesDecrypt(
            encrypted: encrypted.sublist(16),
            key: key.sublist(0, 32),
            iv: key.sublist(32),
            aesMode: 'cbc',
        ),
    );
}

fun getSourcesFromCache(slug, episode) {
    final src = Collection.findList(sourceCache[slug], fun (i, x) {
        return x['episode'] == episode;
    });

    if (src == null) {
        return Flaw.throwFlaw('Unknown episode: ${episode}');
    }

    if (src['url'] == null) {
        final decrypted = decryptSourceURL(src['source']);
        src['url'] = Http.ensureURL('https://cdn.twist.moe${decrypted}');
    }

    return [
        EpisodeSource(
            url: src['url'],
            headers: src['headers'],
            quality: 'unknown',
            locale: src['locale'],
        ),
    ];
}

fun getSources(episode) {
    final slug = extractSlugFromURL(episode.url);

    if (sourceCache[slug] != null) {
        return getSourcesFromCache(slug, episode.episode);
    }

    return Promise.resolve(
        () => Http.fetch(
            method: 'get',
            url: animeSourcesURL(slug),
            headers: defaultHeaders,
        ),
        onDone: fun (resp) {
            final parsed = Converter.jsonDecode(resp.body);

            sourceCache[slug] = Collection.mapList(parsed, fun (i, x) {
                final currentEpisode = x['number'].toString();

                return {
                    'episode': currentEpisode,
                    'quality': 'unknown',
                    'source': x['source'],
                    'headers': {
                        'Referer': Http.ensureURL('${BASE_URL}/a/${slug}/${currentEpisode}'),
                        'User-Agent': Http.defaultUserAgent,
                    },
                    'locale': episode.locale,
                };
            });

            return getSourcesFromCache(slug, episode.episode);
        }
    );
}
