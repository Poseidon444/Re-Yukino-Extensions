external fun decryptCryptoJsAES(salted: str, decrypter: str, length: num) -> str;
external fun fetch(data: Map);
external fun httpUserAgent() -> str;

const FuzzySearcher: type = fun(terms: str, limit: num) -> List<Map>;
external fun createFuzzy(data: List<Map>, keys: List<Map>) -> FuzzySearcher;

external class HtmlElement {
    const classes: List<str>;
    const id: str?;
    const text: str?;
    const innerHtml: str;
    const outerHtml: str;
    const attributes: Map<str>;

    fun querySelector(selector: str) -> HtmlElement?;
    fun querySelectorAll(selector: str) -> List<HtmlElement>;
}
external fun parseHtml(html: str) -> HtmlElement;

external fun jsonEncode(data) -> str;
external fun jsonDecode(data: str);

external class RegExpMatchResult {
    const input: str;

    fun group(group: num) -> str?;
}
external fun regexMatch(regex: str, text: str) -> RegExpMatchResult?;
external fun regexMatchAll(regex: str, text: str) -> List<RegExpMatchResult>;

const ListMapper: type = fun(i: num, item: any) -> any;
external fun mapList(data: List<any>, mapper: ListMapper) -> str;

const ListFilterer: type = fun(i: num, item: any) -> bool;
external fun filterList(data: List<any>, filterer: ListFilterer) -> List<any>;
external fun findList(data: List<any>, filterer: ListFilterer) -> any?;

external fun regexReplaceAll(data: str, from: str, to: str) -> str;
external fun regexReplaceFirst(data: str, from: str, to: str) -> str;

const ResolveFutureCallback: type = fun(err: str?, result);
external fun resolveFuture(future, fn: ResolveFutureCallback);

external fun throwError(err: str) -> void;
external fun ensureURL(url: str) -> str;

/* Extractor */
const baseURL = 'https://twist.moe';
const apiURL = 'https://api.twist.moe/api';

const _twistDecryptKey = '267041df55ca2b36f2e322d05ee2c9cf';
const _twistAccessToken = '0df14814b9e590a1f26d3071a4ed7974';

const defaultHeaders: Map<str> = {
    'User-Agent': httpUserAgent(),
    'Referer': baseURL,
    'x-access-token': _twistAccessToken,
}

fun searchApiURL() -> str {
    return '${apiURL}/anime';
}

fun animeURL(slug: str) -> str {
    return ensureURL('${baseURL}/a/${slug}');
}

fun animeApiURL(slug: str) -> str {
    return ensureURL('${apiURL}/anime/${slug}');
}

fun animeSourcesURL(slug: str) -> str {
    return'${animeApiURL(slug)}/sources';
}

fun extractSlugFromURL(url: str) -> str? {
    const match: RegExpMatchResult? = regexMatch('https?:\\/\\/twist\\.moe\\/a\\/([^\\/]+)', url);
    return match != null ? match.group(1) : match;
}

fun defaultLocale() -> str {
    return "en";
}

let searcher: FuzzySearcher? = null;
fun search(terms: str, locale: str) {
    if (searcher != null) {
        return searcher(terms, 10);
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': searchApiURL(),
        'headers': defaultHeaders
    }), fun (err: str?, resp) {
        if (err != null) return throwError(err);

        const data: List<Map> = mapList(jsonDecode(resp['body']), fun (i: num, x: Map) {
            return {
                'title': x['title'],
                'altTitle': x['altTitle'] != null ? x['altTitle'] : '',
                'url': ensureURL(animeURL(x['slug']['slug'])),
                'locale': locale,
            };
        });

        searcher = createFuzzy(data, [{
            'key': 'title',
            'weight': 2
        }, {
            'key': 'altTitle',
            'weight': 1
        }]);

        return searcher(terms, 10);
    });
}

fun getInfo(url: str, locale: str) {
    const slug: str? = extractSlugFromURL(url);
    if (slug == null) {
        return throwError('Failed to parse "slug"');
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': animeApiURL(slug),
        'headers': defaultHeaders
    }), fun (err: str?, resp) {
        if (err != null) return throwError(err);

        const parsed: Map = jsonDecode(resp['body']);
        const animeURLP = animeURL(slug);

        return {
            'title': parsed['title'],
            'url': animeURLP,
            'episodes': mapList(parsed['episodes'], fun (i: num, x: Map) {
                const epNum = x['number'].toString();
                return {
                    'episode': epNum,
                    'url': ensureURL('${animeURLP}/${epNum}'),
                    'locale': locale,
                };
            }),
            'locale': locale,
            'availableLocales': [
                locale
            ]
        };
    });
}

const sourceCache: Map<List<Map>> = {};
fun getSources(episode: Map) {
    const slug: str? = extractSlugFromURL(episode['url']);
    if (slug == null) {
        return throwError('Failed to parse "slug"');
    }

    const ep: num = int.parse(episode['episode']);

    fun returnFromCache() {
        const src: Map? = findList(sourceCache[slug], fun (i: num, x: Map) {
            return x['episode'] == ep;
        });
        if (src == null) {
            return throwError('Unknown episode: ${ep}');
        }

        if (src['url'] == null) {
            const decrypted = decryptCryptoJsAES(src['source'], _twistDecryptKey, 48);
            src['url'] = ensureURL('https://cdn.twist.moe${decrypted}');
        }

        return [src];
    }

    if (sourceCache[slug] != null) {
        return returnFromCache();
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': animeSourcesURL(slug),
        'headers': defaultHeaders
    }), fun (err: str?, resp) {
        if (err != null) return throwError(err);

        const parsed: List<Map> = jsonDecode(resp['body']);

        sourceCache[slug] = mapList(parsed, fun (i: num, x: Map) {
            const ep: num = x['number'];
            return {
                'episode': ep,
                'quality': 'unknown',
                'source': x['source'],
                'headers': {
                  'Referer': ensureURL('${baseURL}/a/${slug}/${ep}'),
                  'User-Agent': httpUserAgent()
                },
                'locale': episode['locale']
            };
        });

        return returnFromCache();
    });
}
