const BASE_URL = 'https://www2.gogoanime.cm';

final defaultHeaders = {
    'User-Agent': Http.defaultUserAgent,
    'Referer': BASE_URL,
}

var webview;

fun getWebview(trace) {
    if (webview != null && !webview.disposed) {
        trace.add('Returning previous DOM');
        return webview;
    }

    trace.add('Creating new DOM');

    return Promise.resolve(
        () => Webview.create(),
        trace: trace,
        onDone: fun (res) {
            webview = res;
            return webview;
        }
    );
}

fun getSite(url, trace) {
    trace.add('Preparing DOM');

    return Promise.resolve(
        () => getWebview(trace),
        trace: trace,
        onDone: fun (webview) {
            trace.add('Opening URL: "${url}"');

            return Promise.resolve(
                () => webview.open(url, 'domContentLoaded'),
                trace: trace,
                onDone: fun (_) {
                    trace.add('Trying to bypass cloudflare');

                    return Promise.resolve(
                        () => webview.tryBypassCloudfareBrowserVerification(),
                        trace: trace,
                        onDone: fun (bypassed) {
                            if (!bypassed) return Flaw.throwFlaw('Failed to bypass cloudflare', null, trace);

                            return webview;
                        }
                    );
                }
            );
        }
    );
}

fun searchURL(terms) {
    return Http.ensureURL('${BASE_URL}/search.html?keyword=${terms}');
}

fun episodesApiURL(id, start, end) {
    return Http.ensureURL('https://ajax.gogo-load.com/ajax/load-list-episode?ep_start=${start}&ep_end=${end}&id=${id}');
}

fun defaultLocale() {
    return 'en';
}

fun search(terms, locale) {
    final trace = TaskTrace();
    final url = searchURL(terms);
    
    trace.add('Getting URL: "${url}"');

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            trace.add('Getting HTML of "${url}"');

            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    if (html == null) return Flaw.throwFlaw('No html was received', null, trace);

                    trace.add('Parsing HTML of "${url}"');
                    final document = HtmlElement.parse(html);

                    return Collection.mapList(
                        document.querySelectorAll('.items li'),
                        fun (i, x) {
                            final titleElement = x.querySelector('.name a');
                            final url = titleElement.attributes['href'].trim();
                            final thumbnail = x.querySelector('.img img').attributes['src'].trim();

                            return SearchInfo(
                                title: titleElement.text.trim(),
                                url: Http.ensureURL('${BASE_URL}${url}'),
                                thumbnail: ImageDescriber(
                                    url: Http.ensureURL(thumbnail),
                                    headers: defaultHeaders,
                                ),
                                locale: locale,
                            );
                        }
                    );
                },
            );
        }
    );
}

fun getInfo(_url, locale) {
    final trace = TaskTrace();
    final url = Http.ensureURL(_url);

    trace.add('Getting URL: "${url}"');

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            trace.add('Getting HTML of "${url}"');

            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    if (html == null) return Flaw.throwFlaw('No html was received', null, trace);

                    final document: HtmlElement = HtmlElement.parse(html);

                    final epPagesElement: List<HtmlElement> = document.querySelectorAll('#episode_page a');
                    final epStart: str = epPagesElement.first.attributes['ep_start'].trim();
                    final epEnd: str = epPagesElement.last.attributes['ep_end'].trim();
                    final epId: str = document.querySelector('input#movie_id').attributes['value'].trim();
                    final epURL: str = episodesApiURL(epId, epStart, epEnd);

                    trace.add('Getting URL: "${epURL}"');

                    return Promise.resolve(
                        () => getSite(epURL, trace),
                        trace: trace,
                        onDone: fun (_) {
                            trace.add('Getting HTML of "${epURL}"');

                            return Promise.resolve(
                                () => webview.getHtml(),
                                trace: trace,
                                onDone: fun (epHtml) {
                                    if (epHtml == null) return Flaw.throwFlaw('No html was received', null, trace);

                                    final episodes: Map = Collection.mapList(
                                        HtmlElement.parse(epHtml).querySelectorAll('#episode_related a'),
                                        fun (i: num, x: HtmlElement) {
                                            final episode = x.querySelector('.name').text.replaceFirst('EP', '').trim();
                                            final url = x.attributes['href'].trim();
                                            
                                            return EpisodeInfo(
                                                episode: episode,
                                                url: Http.ensureURL('${BASE_URL}/${url}'),
                                                locale: locale
                                            );
                                        }
                                    );

                                    return AnimeInfo(
                                        title: document.querySelector('.anime_info_body_bg h1').text.trim(),
                                        url: Http.ensureURL(url),
                                        thumbnail: ImageDescriber(
                                            url: Http.ensureURL(document.querySelector('.anime_info_body_bg img').attributes['src'].trim()),
                                            headers: defaultHeaders,
                                        ),
                                        episodes: episodes,
                                        locale: locale,
                                        availableLocales: [
                                            locale
                                        ]
                                    );
                                }
                            );
                        }
                    );
                }
            );
        }
    );
}

fun getSources(episode) {
    final trace = TaskTrace();
    final url = episode.url;

    trace.add('Getting URL: "${url}"');

    return Promise.resolve(
        () => getSite(url, trace),
        trace: trace,
        onDone: fun (_) {
            trace.add('Getting HTML of "${url}"');

            return Promise.resolve(
                () => webview.getHtml(),
                trace: trace,
                onDone: fun (html) {
                    if (html == null) return Flaw.throwFlaw('No html was received', null, trace);

                    final defaultSourceProps = {
                        'quality': 'unknown',
                        'locale': episode.locale
                    };

                    return Promise.resolveAll(
                        Collection.filterList(
                            Collection.mapList(
                                HtmlElement.parse(html).querySelectorAll('.anime_muti_link ul > li'),
                                fun (i, x) {
                                    final link = x.querySelector('a').attributes['data-video'];

                                    if (link != null) {
                                        if (x.classes.contains('anime') || x.classes.contains('vidcdn')) {
                                            return () => _parseGogoPlay(link, trace, defaultSourceProps);
                                        }
                                        // TODO: Redo these
                                        // else if (x.classes.contains('streamsb')) {
                                        //     return () => _parseSbPlay(link, trace, defaultSourceProps);
                                        // } else if (x.classes.contains('xstreamcdn')) {
                                        //     return () => _parseXstreamCdn(link, trace, defaultSourceProps);
                                        // }
                                        // else if (testStreamTape(xlink)) {
                                        //    return parseStreamTape(link, defaultSourceProps);
                                        // }
                                    }

                                    return null;
                                }
                            ),
                            (i, x) => x != null,
                        ),
                        trace: trace,
                        onDone: fun (res) {
                            return Collection.flattenList(res, 1);
                        }
                    );
                }
            );
        }
    );
}

// SbPlay Scraper
final _sbPlayURL = 'https://sbplay.org';
final _sbPlayHeaders = {
    'User-Agent': Http.defaultUserAgent,
};

fun _parseSbPlay(url, trace, defaultResult) {
    return Promise.resolve(
        () => Http.fetch(
            method: 'get',
            url: Http.ensureURL(Regex('(\\/embed-|\\/e\\/)').replaceFirst(url, '/d/')),
            headers: _sbPlayHeaders
        ),
        trace: trace,
        onDone: fun (resp) {
            return Promise.resolveAll(
                Collection.mapList(
                    Regex('onclick="download_video\\(\'([^\']+)\',\'([^\']+)\',\'([^\']+)\'\\)"').allMatches(resp.body),
                    fun (i, x) {
                        final code = x.group(1);
                        final mode = x.group(2);
                        final hash = x.group(3);

                        return () => Promise.wait(3000, fun () {
                            return Promise.resolve(
                                () => Http.fetch(
                                    method: 'get',
                                    url: Http.ensureURL('${_sbPlayURL}/dl?op=download_orig&id=${code}&mode=${mode}&hash=${hash}'),
                                    headers: _sbPlayHeaders
                                ),
                                onDone: fun (resp) {
                                    final match = Regex('<a href="([^"]+)">Direct Download Link<\\/a>').firstMatch(resp.body);
                                    if (match == null) return null;

                                    return EpisodeSource(
                                        url: Http.ensureURL(match.group(1)),
                                        headers: _sbPlayHeaders,
                                        quality: defaultResult['quality'],
                                        locale: defaultResult['locale'],
                                    );
                                }
                            );
                        });
                    }
                ),
                onDone: fun (res) {
                    return Collection.filterList(res, (i, x) => x != null);
                }
            );
        }
    );
}

// GogoPlay Scraper
final _gogoPlayURL = 'https://gogoplay.io';
final _gogoPlayHeaders = {
    'User-Agent': Http.defaultUserAgent,
    'Referer': _gogoPlayURL,
};

fun _gogoPlayAjax(id) {
    return Http.ensureURL('${_gogoPlayURL}/encrypt-ajax.php?id=${id}&time=00000000000000000000');
}

// Source:
//  - https://github.com/saikou-app/saikou/blob/master/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
//  - https://github.com/justfoolingaround/animdl/blob/master/animdl/core/codebase/extractors/gogoplay/__init__.py
fun _parseGogoPlay(url, trace, defaultResult) {
    return Promise.resolve(
        () => Http.fetch(
            method: 'get',
            url: Http.ensureURL(url),
            headers: _gogoPlayHeaders
        ),
        trace: trace,
        onDone: fun (resp) {
            final document = HtmlElement.parse(resp.body);
            
            final id = Regex('id=([^&]+)').firstMatch(url).group(1);
            final encrypted = document.querySelector('script[data-name="crypto"]').attributes['data-value'];
            final iv = document.querySelector('script[data-name="ts"]').attributes['data-value'];

            final secretKey = Crypto.aesDecrypt(
                encrypted: Converter.base64Decode(encrypted),
                key: Converter.utf8Encode('${iv}${iv}'),
                iv: Converter.utf8Encode(iv),
                aesMode: 'cbc',
            );

            final encryptedId = Crypto.aesEncrypt(
                input: Converter.utf8Encode(id),
                key: secretKey,
                iv: Converter.utf8Encode('0000000000000000'),
                aesMode: 'cbc',
            );

            return Promise.resolve(
                () => Http.fetch(
                    method: 'get',
                    url: _gogoPlayAjax(Converter.base64Encode(encryptedId)),
                    headers: Collection.mergeMap(_gogoPlayHeaders, {
                        'X-Requested-With': 'XMLHttpRequest',
                    }),
                ),
                trace: trace,
                onDone: fun (resp) {
                    final parsed = Converter.jsonDecode(resp.body);

                    return Collection.mapList(
                        Collection.filterList(parsed['source'], (i, x) => x['type'] == 'mp4'),
                        fun (i, x) {
                            return EpisodeSource(
                                url: Http.ensureURL(x['file']),
                                headers: _gogoPlayHeaders,
                                quality: x['label'],
                                locale: defaultResult['locale'],
                            );
                        },
                    );
                },
            );
        }
    );
}

// // StreamTape Scraper
// final _streamTapeURL = 'https://streamtape.com';
// final _streamTapeHeaders = {
//     'User-Agent': Http.defaultUserAgent,
// };

// fun _parseStreamTape(url, trace, defaultResult) {
//     return Promose.resolve(
//             () => fetch(
//             method: 'get',
//             url: ensureURL(url),
//             headers: streamTapeHeaders
//         ),
//         fun (err, resp) {
//         final match = regexMatch('id="videolink"[\\s\\S]+\\.innerHTML[\\s]+=[\\s\\S]+(id=[^\'"]+)', resp['body']);
//         final params: str = match != null ? match.group(1) : null;

//         return params != null ? [
//             mergeMap(defaultResult, {
//                 'url': ensureURL('${streamTapeURL}/get_video?${params}'),
//                 'headers': streamTapeHeaders
//             })
//         ] : [];
//     });
// }

// XStreamCDN Scraper
// final _xstreamCdnURL = 'https://embedsito.com';
// final _xstreamCdnHeaders = {
//     'User-Agent': Http.defaultUserAgent,
//     'Referer': _xstreamCdnURL
// };

// fun _parseXstreamCdn(url, trace, defaultResult) {
//     return Promise.resolve(
//         () => Http.fetch(
//             method: 'post',
//             url: Http.ensureURL(url.replaceFirst('/v', '/api/source')),
//             headers: _xstreamCdnHeaders
//         ),
//         trace: trace,
//         onDone: fun (resp) {
//             final parsed = Converter.decodeJson(resp.body);

//             return Collection.filterList(
//                 Collection.mapList(parsed['data'], fun (i, x) {
//                     if (x['type'] != 'mp4') return null;

//                     return EpisodeSource(
//                         url: Http.ensureURL(x['file']),
//                         headers: _xstreamCdnHeaders,
//                         quality: x['label'],
//                         locale: defaultResult['locale'],
//                     );
//                 }),
//                 (i: num, x) => x != null
//             );
//         }
//     );
// }